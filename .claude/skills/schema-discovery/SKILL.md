# /schema-discovery — Design and apply the database schema

## Description

Interactive schema design wizard. Reads PRDs and screen specs to auto-propose entities, then refines with the user and applies via Supabase MCP. Generates cross-platform model files.

## Trigger

User says "/schema-discovery" or "design the schema" or "set up the database"

## Prerequisites

- `/product-discovery` must be complete (needs PRDs)
- `/design-discovery` should be complete (screen specs inform data needs)
- Supabase MCP server must be connected

## Instructions

### Step 1: Read Context

Read all available context:
- `docs/PRDs/` — feature specs with data requirements
- `docs/design/screens/` — screen specs (what data each screen displays/modifies)
- `docs/design/information-architecture.md` — screen inventory
- `tracker.md` — project context

### Step 2: Auto-Propose Schema

Based on the features and screen data needs, propose:

1. **Entities:** List each table with columns, types, constraints
2. **Relationships:** Foreign keys, junction tables for many-to-many
3. **RLS Policies:** Row-level security for each table (who can read/write what)
4. **Triggers:** Auto-created profiles, updated_at timestamps, etc.
5. **Indexes:** For common query patterns identified from screen specs

Write the proposal to `docs/schema-proposal.md` as annotated SQL.

### Step 3: Schema Review

Spawn the `schema-reviewer` agent to review the proposed SQL for:
- Normalization issues
- Missing indexes
- RLS gaps
- Naming convention violations

Present the proposal and review feedback to the user.

### Step 4: Interactive Refinement

Walk through each entity with the user:
- Confirm table name and columns
- Discuss types and constraints
- Review RLS policies (who sees what?)
- Adjust based on feedback

### Step 5: Apply Schema

Using Supabase MCP tools:

1. `list_tables` — check what already exists
2. For each table, `apply_migration` with the SQL
3. `generate_typescript_types` — write types file for Next.js
4. Generate Swift model files using the model template pattern
5. Generate Kotlin model files using the model template pattern
6. `get_advisors` (security) — check for vulnerabilities

### Step 6: Generate Cross-Platform Models

For each table, create:
- **TypeScript:** Types are auto-generated by `generate_typescript_types`
- **Swift:** `Models/<Entity>Model.swift` with Codable struct + CodingKeys
- **Kotlin:** `data/model/<Entity>Model.kt` with @Serializable data class

Use the patterns from `references/model-templates/` if available.

### Step 7: Update Tracker

Update `tracker.md`:
- Set Phase "Schema Design" = Done, 100%
- Mark each feature's "Schema applied" checkbox
- Log schema decisions in Decision Log
- Suggest next step: automation setup or `/build-feature`
